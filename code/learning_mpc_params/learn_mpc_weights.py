# í•™ìŠµ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸

"""
Learn MPC Cost Weights from Demonstration Data

ì‹œì—° ë°ì´í„°ë¡œë¶€í„° KKT ì¡°ê±´ ì™„í™”ë¥¼ ì´ìš©í•˜ì—¬ MPC ë¹„ìš©í•¨ìˆ˜ ê°€ì¤‘ì¹˜ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.

ì‹¤í–‰ ìˆœì„œ:
    1. python main.py  (ì‹œì—° ë°ì´í„° ìƒì„±)
    2. python learn_mpc_weights.py  (ì´ ìŠ¤í¬ë¦½íŠ¸ - ê°€ì¤‘ì¹˜ í•™ìŠµ)
    3. python apply_learned_mpc.py  (í•™ìŠµëœ ê°€ì¤‘ì¹˜ë¡œ MPC ì‹¤í–‰)
"""

import numpy as np
import mujoco
import sys
import os

# í”„ë¡œì íŠ¸ ê²½ë¡œ ì¶”ê°€
sys.path.append('/home/seohy/colcon_ws/src/ffw2/code')

from dataGet.config import PathConfig, MPCConfig, SimulationConfig
from dataGet.robot_setup import setup_robot
from .inverse_optimal_control import InverseOptimalControl


def main():
    print("\n" + "="*80)
    print("ðŸŽ“ Learning MPC Cost Weights from Expert Demonstrations")
    print("ðŸŽ“ Learning MPC Cost Weights from Expert Demonstrations")
    print("   Method: Inverse Optimal Control with Relaxed KKT Conditions")
    print("="*80)
    
    # ===============================
    # 1. Load MuJoCo Model
    # ===============================
    paths = PathConfig.get_paths()
    xml_path = paths['xml_path']
    
    print(f"\nðŸ“ Loading model: {xml_path}")
    model = mujoco.MjModel.from_xml_path(xml_path)
    print("âœ… Model loaded")
    
    # ===============================
    # 2. Setup Robot
    # ===============================
    robot = setup_robot(model)
    controlled_joint_ids = robot.get_controlled_joint_ids()
    joint_names = robot.get_joint_names()
    
    print(f"\nðŸ¤– Controlled joints: {joint_names}")
    print(f"   Joint IDs: {controlled_joint_ids}")
    
    # ===============================
    # 3. Load Demonstration Data
    # ===============================
    dataset_path = PathConfig.DATASET_PATH
    
    if not os.path.exists(dataset_path):
        print(f"\nâŒ Error: Dataset not found at {dataset_path}")
        print("   Please run main.py first to generate demonstration data")
        return
    
    print(f"\nðŸ“Š Loading demonstration data: {dataset_path}")
    
    # ===============================
    # 4. Create IOC Learner
    # ===============================
    ioc = InverseOptimalControl(
        model=model,
        joint_ids=controlled_joint_ids,
        horizon=MPCConfig.HORIZON,
        dt=SimulationConfig.SIM_DT
    )
    
    # ì‹œì—° ë°ì´í„° ë¡œë“œ
    demonstrations = ioc.load_demonstration_data(dataset_path)
    
    # ===============================
    # 5. Learn Cost Weights
    # ===============================
    # í˜„ìž¬ configì˜ ê°€ì¤‘ì¹˜ë¥¼ ì´ˆê¸°ê°’ìœ¼ë¡œ ì‚¬ìš©
    from dataGet.config import CostWeights
    
    # theta_init = np.array([
    #     CostWeights.Q_POS[0, 0],
    #     CostWeights.Q_VEL[0, 0],
    #     CostWeights.R_TAU[0, 0],
    #     CostWeights.Q_TERMINAL[0, 0],
    #     CostWeights.Q_VEL_TERMINAL[0, 0],
    #     CostWeights.Q_VEL_REF[0, 0]
        
    # ])

    theta_init = np.array([
        1000.0,    # Q_pos
        25.0,     # Q_vel    
        0.001,  # R_tau
        1000.0,    # Q_terminal
        25.0,     # Q_vel_terminal
        10.0      # Q_vel_ref
    ])

    print(f"\nðŸ“ Initial weights from config:")
    print(f"   Q_pos: {theta_init[0]:.2f}")
    print(f"   Q_vel: {theta_init[1]:.2f}")
    print(f"   R_tau: {theta_init[2]:.6f}")
    print(f"   Q_terminal: {theta_init[3]:.2f}")
    print(f"   Q_vel_terminal: {theta_init[4]:.2f}")
    print(f"   Q_vel_ref: {theta_init[5]:.2f}")

    
    # í•™ìŠµ ì‹¤í–‰
    theta_learned, result = ioc.learn_cost_weights(
        demonstrations=demonstrations,
        theta_init=theta_init
    )
    
    # ===============================
    # 6. Compare Results
    # ===============================
    ioc.compare_parameters(theta_learned, theta_init)
    
    # ===============================
    # 7. Visualize Results
    # ===============================
    print("\nðŸ“ˆ Generating visualizations...")
    ioc.visualize_results(theta_learned, demonstrations, n_samples=5)
    
    # ===============================
    # 8. Save Learned Weights
    # ===============================
    output_path = '/home/seohy/colcon_ws/src/ffw2/code/learning_mpc_params/learned_mpc_weights.npz'
    
    np.savez(
        output_path,
        theta_learned=theta_learned,
        theta_init=theta_init,
        joint_names=joint_names,
        horizon=MPCConfig.HORIZON,
        dt=SimulationConfig.SIM_DT,
        optimization_result={
            'success': result.success,
            'final_cost': result.fun,
            'nit': result.nit,
            'message': result.message
        }
    )
    
    print(f"\nðŸ’¾ Saved learned weights: {output_path}")
    
    # ===============================
    # 9. Generate Config File
    # ===============================
    config_code = f"""
    # Learned MPC Cost Weights
    # Generated by Inverse Optimal Control

    import numpy as np

    class LearnedCostWeights:
    '''MPC ë¹„ìš©í•¨ìˆ˜ ê°€ì¤‘ì¹˜ (ì—­ìµœì ì œì–´ë¡œ í•™ìŠµë¨)'''
    
    # í•™ìŠµëœ ê°€ì¤‘ì¹˜
    Q_POS = np.eye(1) * {theta_learned[0]:.4f}
    Q_VEL = np.eye(1) * {theta_learned[1]:.4f}
    R_TAU = np.eye(1) * {theta_learned[2]:.6f}
    Q_TERMINAL = np.eye(1) * {theta_learned[3]:.4f}
    Q_VEL_TERMINAL = np.eye(1) * {theta_learned[4]:.4f}
    Q_VEL_REF = np.eye(1) * {theta_learned[5]:.4f}
    
    # ì›ëž˜ ê°€ì¤‘ì¹˜ (ë¹„êµìš©)
    Q_POS_ORIGINAL = np.eye(1) * {theta_init[0]:.4f}
    Q_VEL_ORIGINAL = np.eye(1) * {theta_init[1]:.4f}
    R_TAU_ORIGINAL = np.eye(1) * {theta_init[2]:.6f}
    Q_TERMINAL_ORIGINAL = np.eye(1) * {theta_init[3]:.4f}
    Q_VEL_TERMINAL_ORIGINAL = np.eye(1) * {theta_init[4]:.4f}
    Q_VEL_REF_ORIGINAL = np.eye(1) * {theta_init[5]:.4f}
"""
    
    config_path = '/home/seohy/colcon_ws/src/ffw2/code/learning_mpc_params/learned_weights_config.py'
    with open(config_path, 'w') as f:
        f.write(config_code)
    
    print(f"ðŸ’¾ Generated config file: {config_path}")
    
    # ===============================
    # 10. Summary
    # ===============================
    print("\n" + "="*80)
    print("âœ… Learning Completed Successfully!")
    print("="*80)
    
    print(f"\nðŸ“‹ Summary:")
    print(f"   Demonstrations used: {len(demonstrations)}")
    print(f"   Optimization success: {result.success}")
    print(f"   Final â€–âˆ‡Lâ€–Â²: {result.fun:.6e}")
    print(f"   Iterations: {result.nit}")
    
    print(f"\nðŸŽ¯ Parameter Changes:")
    for i, name in enumerate(['Q_pos', 'Q_vel', 'R_tau', 'Q_terminal']):
        ratio = theta_learned[i] / theta_init[i]
        change = ((theta_learned[i] - theta_init[i]) / theta_init[i]) * 100
        arrow = "â†‘" if change > 0 else "â†“"
        print(f"   {name:12s}: {theta_init[i]:10.4f} â†’ {theta_learned[i]:10.4f}  "
              f"({change:+6.1f}% {arrow})")
    
    print(f"\nðŸ“¦ Output Files:")
    print(f"   - {output_path}")
    print(f"   - {config_path}")
    print(f"   - /mnt/user-data/outputs/ioc_results.png")
    
    print(f"\nðŸš€ Next Steps:")
    print(f"   1. Review the visualization plots")
    print(f"   2. Run apply_learned_mpc.py to test the learned weights")
    print(f"   3. Compare performance with original weights")
    
    print("\n" + "="*80 + "\n")


if __name__ == "__main__":
    main()